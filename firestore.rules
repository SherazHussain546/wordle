/**
 * @file Overview
 * This ruleset enforces a strict user-ownership model for user-related data
 * and provides public read access to daily words and the word list.
 *
 * @data_structure
 * - /users/{userId}: Stores user profiles. Each user can only access their own profile.
 * - /users/{userId}/gameStates/{gameStateId}: Stores game states for each user.
 *   Each user can only access their own game states.
 * - /users/{userId}/statistics: Stores statistics for each user.
 *   Each user can only access their own statistics.
 * - /dailyWords/{dailyWordDate}: Stores the daily word for a given date. This collection is publicly readable.
 *   Writes are not allowed in this prototype, but should later be restricted.
 * - /wordList/{word}: Stores the list of valid words. This collection is publicly readable.
 *   Writes are not allowed in this prototype, but should later be restricted.
 *
 * @key_security_decisions
 * - User listing is disallowed.
 * - Ambiguous relationships default to strict owner-only access.
 * - Daily words and the word list are publicly readable but require authentication for writes.
 *
 * @denormalization_for_authorization
 * - GameState documents include a denormalized `userId` to allow ownership checks without additional reads.
 *
 * @structural_segregation
 * - Private user data is stored under /users/{userId}, while public data (dailyWords, wordList) is stored at the top level.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secure user profiles. Only the authenticated user can read/write their own profile.
     * @path /users/{userId}
     * @allow (create) - Authenticated user creates their profile with matching userId.
     * @allow (get, update, delete) - Authenticated user reads/writes their own profile.
     * @deny (create, get, update, delete) - Any user attempts to access another user's profile.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secure game states. Only the authenticated user can read/write their own game states.
     * @path /users/{userId}/gameStates/{gameStateId}
     * @allow (create, get, update, delete) - Authenticated user reads/writes their own game state.
     * @deny (create, get, update, delete) - Any user attempts to access another user's game state.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/gameStates/{gameStateId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secure user statistics. Only the authenticated user can read/write their own statistics.
     * @path /users/{userId}/statistics
     * @allow (create, get, update, delete) - Authenticated user reads/writes their own statistics.
     * @deny (create, get, update, delete) - Any user attempts to access another user's statistics.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/statistics {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

       function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allow public read access to daily words.  Writes are not yet secured.
     * @path /dailyWords/{dailyWordDate}
     * @allow (get, list) - Any user can read the daily word.
     * @deny (create, update, delete) - No user can modify the daily word without authentication (TODO).
     * @principle Allows public read access while restricting writes.
     */
    match /dailyWords/{dailyWordDate} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Allow public read access to the word list. Writes are not yet secured.
     * @path /wordList/{word}
     * @allow (get, list) - Any user can read the word list.
     * @deny (create, update, delete) - No user can modify the word list without authentication (TODO).
     * @principle Allows public read access while restricting writes.
     */
    match /wordList/{word} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }
  }
}